using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace CollectionDataReaderGenerator;

[Generator]
public class CollectionDataReaderIncrementalGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider
            (
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx)
            )
            .Where(t => t.ReportAttributeFound)
            .Select((t, _) => t.Item1);

        context.RegisterSourceOutput
        (
            context.CompilationProvider.Combine(provider.Collect()),
            ((ctx, t) => GenerateCode
            (
                ctx,
                t.Left,
                t.Right
            ))
        );
    }

    private static (ClassDeclarationSyntax, bool ReportAttributeFound) GetClassDeclarationForSourceGen(GeneratorSyntaxContext context)
    {
        var stringData = context.SemanticModel.GetDiagnostics().Select(x => x.ToString());
        Console.WriteLine(string.Join("\n", stringData));

        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
        foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
            {
                continue;
            }

            string attributeName = attributeSymbol.ContainingType.Name;

            if (attributeName == nameof(DataReaderAttribute))
            {
                return (classDeclarationSyntax, true);
            }
        }

        return (classDeclarationSyntax, false);
    }

    private void GenerateCode
    (
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations
    )
    {
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
            {
                continue;
            }

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            var className = classDeclarationSyntax.Identifier.Text;

            var columnProperties = GetColumnProperties(classSymbol);

            var code = $$"""
// <auto-generated/>

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;

namespace {{namespaceName}};

class {{className}}DataReader : DbDataReader
{
    private readonly IEnumerator<{{className}}> _source;
    private {{className}} _current;

    public {{className}}DataReader(IEnumerable<{{className}}> source)
    {
        _source = source.GetEnumerator();
    }

    public override DataTable GetSchemaTable()
    {
        DataTable schemaTable = new DataTable()
        {
            Columns = {
                {
                    "ColumnOrdinal",
                    typeof (int)
                },
                {
                    "ColumnName",
                    typeof (string)
                },
                {
                    "DataType",
                    typeof (Type)
                },
                {
                    "ColumnSize",
                    typeof (int)
                },
                {
                    "AllowDBNull",
                    typeof (bool)
                },
                {
                    "IsKey",
                    typeof (bool)
                },
                {
                    "NumericPrecision",
                    typeof (short)
                },
                {
                    "NumericScale",
                    typeof (short)
                },
            }
        };

{{GetSchemaTableRows(columnProperties)}}

        return schemaTable;
    }
    
    public override bool GetBoolean(int ordinal)
    {
        return ordinal switch
        {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(Boolean))}}
            < 0 or > {{columnProperties.Count - 1}} => throw new ArgumentOutOfRangeException(nameof(ordinal)),
            _ => throw new InvalidCastException()
        };
    }

    public override byte GetByte(int ordinal)
    {
        return ordinal switch
        {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(Byte))}}
            < 0 or > {{columnProperties.Count - 1}} => throw new ArgumentOutOfRangeException(nameof(ordinal)),
            _ => throw new InvalidCastException()
        };
    }

    public override long GetBytes(int ordinal, long dataOffset, byte[]? buffer, int bufferOffset, int length)
    {
        throw new NotImplementedException();
    }

    public override char GetChar(int ordinal)
    {
        return ordinal switch
        {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(Char))}}
            < 0 or > {{columnProperties.Count - 1}} => throw new ArgumentOutOfRangeException(nameof(ordinal)),
            _ => throw new InvalidCastException()
        };
    }

    public override long GetChars(int ordinal, long dataOffset, char[]? buffer, int bufferOffset, int length)
    {
        var str = GetString(ordinal);
        var val2 = str.Length - (int)dataOffset;
        
        if (val2 <= 0)
        {
            return 0;
        }
        
        int count = Math.Min(length, val2);
        str.CopyTo((int) dataOffset, buffer, bufferOffset, count);
        return (long) count;
    }

    public override string GetDataTypeName(int ordinal)
    {
        return ordinal switch
        {
{{GetDataTypeNameSwitchExpression(columnProperties)}}
            _ => throw new ArgumentOutOfRangeException(nameof(ordinal))
        };
    }

    public override DateTime GetDateTime(int ordinal)
    {
        return ordinal switch
        {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(DateTime))}}
            < 0 or > {{columnProperties.Count - 1}} => throw new ArgumentOutOfRangeException(nameof(ordinal)),
            _ => throw new InvalidCastException()
        };
    }

    public override decimal GetDecimal(int ordinal)
    {
        return ordinal switch
        {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(Decimal))}}
            < 0 or > {{columnProperties.Count - 1}} => throw new ArgumentOutOfRangeException(nameof(ordinal)),
            _ => throw new InvalidCastException()
        };
    }

    public override double GetDouble(int ordinal)
    {
        return ordinal switch
        {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(Double))}}
            < 0 or > {{columnProperties.Count - 1}} => throw new ArgumentOutOfRangeException(nameof(ordinal)),
            _ => throw new InvalidCastException()
        };
    }

    public override Type GetFieldType(int ordinal)
    {
        return ordinal switch
        {
{{GetFieldTypeSwitchExpression(columnProperties)}}
            _ => throw new ArgumentOutOfRangeException(nameof(ordinal))
        };
    }

    public override float GetFloat(int ordinal)
    {
        return ordinal switch
        {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(Single))}}
            < 0 or > {{columnProperties.Count - 1}} => throw new ArgumentOutOfRangeException(nameof(ordinal)),
            _ => throw new InvalidCastException()
        };
    }

    public override Guid GetGuid(int ordinal)
    {
        return ordinal switch
        {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(Guid))}}
            < 0 or > {{columnProperties.Count - 1}} => throw new ArgumentOutOfRangeException(nameof(ordinal)),
            _ => throw new InvalidCastException()
        };
    }

    public override short GetInt16(int ordinal)
    {
        return ordinal switch
        {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(Int16))}}
            < 0 or > {{columnProperties.Count - 1}} => throw new ArgumentOutOfRangeException(nameof(ordinal)),
            _ => throw new InvalidCastException()
        };
    }

    public override int GetInt32(int ordinal)
    {
        return ordinal switch
        {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(Int32))}}
            < 0 or > {{columnProperties.Count - 1}} => throw new ArgumentOutOfRangeException(nameof(ordinal)),
            _ => throw new InvalidCastException()
        };
    }

    public override long GetInt64(int ordinal)
    {
        return ordinal switch
        {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(Int64))}}
            < 0 or > {{columnProperties.Count - 1}} => throw new ArgumentOutOfRangeException(nameof(ordinal)),
            _ => throw new InvalidCastException()
        };
    }

    public override string GetName(int ordinal)
    {
        return ordinal switch
        {
{{GetNameSwitchExpression(columnProperties)}}
            _ => throw new ArgumentOutOfRangeException(nameof(ordinal))
        };
    }

    public override int GetOrdinal(string name)
    {
        return name switch
        {
{{GetOrdinalSwitchExpression(columnProperties)}}
            _ => throw new ArgumentOutOfRangeException(nameof(name))
        };
    }

    public override string GetString(int ordinal)
    {
        return ordinal switch
        {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(String))}}
            < 0 or > {{columnProperties.Count - 1}} => throw new ArgumentOutOfRangeException(nameof(ordinal)),
            _ => throw new InvalidCastException()
        };
    }

    public override object GetValue(int ordinal)
    {
        return ordinal switch
        {
{{GetValueSwitchExpression(columnProperties)}}
            _ => throw new ArgumentOutOfRangeException(nameof(ordinal))
        };
    }

    public override int GetValues(object[] values)
    {
        throw new NotImplementedException();
    }

    public override bool IsDBNull(int ordinal)
    {
        return ordinal switch
        {
{{IsDbNullSwitchExpression(columnProperties)}}
            _ => throw new ArgumentOutOfRangeException(nameof(ordinal))
        };
    }

    public override int FieldCount => {{columnProperties.Count}};

    public override object this[int ordinal] => GetValue(ordinal);

    public override object this[string name] => GetValue(GetOrdinal(name));

    public override int RecordsAffected => 0;

    public override bool HasRows
    {
        get
        {
            var hasValue = _source.MoveNext();
            _source.Reset();
            return hasValue;
        }
    }

    public override bool IsClosed => false;

    public override bool NextResult()
    {
        throw new NotImplementedException();
    }

    public override bool Read()
    {
        if (_source.MoveNext())
        {
            _current = _source.Current;
            return true;
        }

        return false;
    }

    public override int Depth => 0;

    public override IEnumerator GetEnumerator()
    {
        return _source;
    }

    protected override void Dispose(bool disposing)
    {
        base.Dispose(disposing);
        _source.Dispose();
    }
}

""";

            context.AddSource($"{className}DataReader.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    private string GetSchemaTableRows(ICollection<ColumnPropertyInfo> columnProperties)
    {
        return string.Join("\n", columnProperties
            .Select(
                p =>
                {
                    var isNullable = p.TypeSymbol.IsReferenceType || p.TypeSymbol.NullableAnnotation == NullableAnnotation.Annotated;
                    return $"            schemaTable.Rows.Add({p.Ordinal}, \"{p.ColumnName}\", typeof({p.TypeSymbol.Name}), -1, {isNullable.ToString().ToLower()}, false, {p.NumericPrecision}, {p.NumericScale});";
                }));
    }

    private string IsDbNullSwitchExpression(ICollection<ColumnPropertyInfo> columnProperties)
    {
        return string.Join("\n", columnProperties
            .Select(p =>
                {
                    var isNullable = p.TypeSymbol.IsReferenceType || p.TypeSymbol.NullableAnnotation == NullableAnnotation.Annotated;
                    return $"            {p.Ordinal} => {(isNullable ? $"_current.{p.SourcePropertyName} is null" : "false")},";
                }
            ));
    }

    private string GetValueSwitchExpression(ICollection<ColumnPropertyInfo> columnProperties)
    {
        return string.Join("\n", columnProperties
            .Select(p => $"            {p.Ordinal} => _current.{p.SourcePropertyName},"));
    }

    private string GetOrdinalSwitchExpression(ICollection<ColumnPropertyInfo> columnProperties)
    {
        return string.Join("\n", columnProperties
            .Select(p => $"            \"{p.ColumnName}\"{(p.ColumnName != p.SourcePropertyName ? $" or \"{p.SourcePropertyName}\"": "")} => {p.Ordinal},"));
    }

    private string GetNameSwitchExpression(ICollection<ColumnPropertyInfo> columnProperties)
    {
        return string.Join("\n", columnProperties
            .Select(p => $"            {p.Ordinal} => \"{p.ColumnName}\","));
    }

    private string GetFieldTypeSwitchExpression(ICollection<ColumnPropertyInfo> columnProperties)
    {
        return string.Join("\n", columnProperties
            .Select(p => $"            {p.Ordinal} => typeof({p.TypeSymbol.Name}),"));
    }

    private string GetDataTypeNameSwitchExpression(ICollection<ColumnPropertyInfo> columnProperties)
    {
        return string.Join("\n", columnProperties
            .Select(p => $"            {p.Ordinal} => nameof({p.TypeSymbol.Name}),"));
    }

    private static string GetTypedValueSwitchExpressionByTypeName(ICollection<ColumnPropertyInfo> columnProperties, string typeName)
    {
        return string.Join("\n", columnProperties
            .Where(p => p.TypeSymbol.Name == typeName)
            .Select(p => $"            {p.Ordinal} => _current.{p.SourcePropertyName},"));
    }

    private static ICollection<ColumnPropertyInfo> GetColumnProperties(INamedTypeSymbol classSymbol)
    {
        if (classSymbol == null)
        {
            return Array.Empty<ColumnPropertyInfo>();
        }

        var properties = new List<ColumnPropertyInfo>();

        var props = classSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => !p.GetAttributes().Any(attr => attr.AttributeClass.Name == nameof(ColumnIgnoreAttribute)))
            .ToList();

        IEnumerable<ColumnPropertyInfo> targetProps;

        if (props.Any(p =>p.GetAttributes().Any(attr => attr.AttributeClass.Name == nameof(ColumnAttribute))))
        {
            var propertyIndex = 0;
            targetProps = props
                .Select
                (
                    p =>
                    {
                        var targetAttr = p
                            .GetAttributes()
                            .FirstOrDefault(attr => attr.AttributeClass.Name == nameof(ColumnAttribute));

                        if (targetAttr == null)
                        {
                            var propInfo = new ColumnPropertyInfo
                            (
                                propertyIndex,
                                p.Name,
                                p.Name,
                                p.Type,
                                (p.Type.Name == nameof(Decimal) ?(short)18 :(short)0),
                                (p.Type.Name == nameof(Decimal) ?(short)5 :(short)0)
                            );

                            propertyIndex++;
                            return propInfo;
                        }

                        var columnNameProp = targetAttr.NamedArguments
                            .FirstOrDefault(x => x.Key == nameof(ColumnAttribute.ColumnName));

                        var columnName = columnNameProp.Value.Value as string ?? p.Name;

                        var ordinal = targetAttr.NamedArguments
                            .FirstOrDefault(x => x.Key == nameof(ColumnAttribute.Ordinal))
                            .Value.Value as int? ?? propertyIndex;

                        var numericPrecision = targetAttr.NamedArguments
                               .FirstOrDefault(x => x.Key == nameof(ColumnAttribute.NumericPrecision))
                               .Value.Value as short?
                           ?? (p.Type.Name == nameof(Decimal) ? (short)18 : (short)0);

                        var numericScale = targetAttr.NamedArguments
                               .FirstOrDefault(x => x.Key == nameof(ColumnAttribute.NumericScale))
                               .Value.Value as short?
                           ?? (p.Type.Name == nameof(Decimal) ? (short)5 : (short)0);

                        propertyIndex++;

                        return new ColumnPropertyInfo(ordinal, columnName, p.Name, p.Type, numericPrecision, numericScale);
                    }
                )
                .OrderBy(p => p.Ordinal);
        }
        else
        {
            var propertyIndex = 0;
            targetProps = props
                .Select
                (
                    p =>
                    {
                        var propInfo = new ColumnPropertyInfo
                        (
                            propertyIndex,
                            p.Name,
                            p.Name,
                            p.Type,
                            (p.Type.Name == nameof(Decimal) ?(short)18 :(short)0),
                            (p.Type.Name == nameof(Decimal) ?(short)5 :(short)0)
                        );

                        propertyIndex++;
                        return propInfo;
                    }
                )
                .OrderBy(p => p.Ordinal);
        }


        properties.AddRange(targetProps);

        return properties;
    }
}
