using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace CollectionDataReaderGenerator;

[Generator]
public class CollectionDataReaderIncrementalGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider
            (
                (s, _) => s is ClassDeclarationSyntax or StructDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx)
            )
            .Where(t => t.ReportAttributeFound)
            .Select((t, _) => t.Item1);

        context.RegisterSourceOutput
        (
            context.CompilationProvider.Combine(provider.Collect()),
            ((ctx, t) => GenerateCode
            (
                ctx,
                t.Left,
                t.Right
            ))
        );
    }

    private static (TypeDeclarationSyntax, bool ReportAttributeFound) GetClassDeclarationForSourceGen(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (TypeDeclarationSyntax)context.Node;

        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
        foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
            {
                continue;
            }

            string attributeName = attributeSymbol.ContainingType.Name;

            if (attributeName == nameof(GenerateDataReaderAttribute))
            {
                return (classDeclarationSyntax, true);
            }
        }

        return (classDeclarationSyntax, false);
    }

    private void GenerateCode
    (
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<TypeDeclarationSyntax> classDeclarations
    )
    {
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
            {
                continue;
            }

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            string sourceClassName;

            if (classDeclarationSyntax.Parent?.SyntaxTree != null
                && compilation.GetSemanticModel(classDeclarationSyntax.Parent?.SyntaxTree).GetDeclaredSymbol(classDeclarationSyntax.Parent) is INamedTypeSymbol parentClassSymbol)
            {
                sourceClassName = $"{parentClassSymbol.Name}.{classSymbol.Name}";
            }
            else
            {
                sourceClassName = classSymbol.Name;
            }

            var targetClassName = classSymbol.Name;

            var columnProperties = GetColumnProperties(classSymbol);

            GenerateDataReader(context, namespaceName,
                targetClassName,
                sourceClassName,
                columnProperties
            );

            var kind = classSymbol.TypeKind;

            GeneratePartialDataReader(context, namespaceName,
                targetClassName,
                kind,
                columnProperties
            );
        }
    }

    private void GeneratePartialDataReader(SourceProductionContext context, string namespaceName, string targetClassName, TypeKind kind, ICollection<ColumnPropertyInfo> columnProperties)
    {
        var code = $$"""
// <auto-generated/>
using System.Collections.Generic;

namespace {{namespaceName}}
{
    public partial {{kind switch
{
    TypeKind.Class => "class",
    TypeKind.Struct => "struct",
    _ => throw new ArgumentException($"TypeKind was {kind}")
}}} {{targetClassName}}
    {
        public static {{targetClassName}}DataReader CreateDataReader(IEnumerable<{{targetClassName}}> source)
        {
            return new {{targetClassName}}DataReader(source);
        }

        public const string SqlText = @"
{{CreateTypeSqlText(targetClassName, columnProperties)}}
";

        public const string TableTypeName = "Generated.{{targetClassName}}";
    }
}
""";

        context.AddSource($"{targetClassName}.g.cs", SourceText.From(code, Encoding.UTF8));
    }

    private string CreateTypeSqlText(string targetClassName, ICollection<ColumnPropertyInfo> columnProperties)
    {
        return
            $@"IF NOT EXISTS (SELECT * FROM sys.schemas WHERE name = N'Generated')
BEGIN
    EXEC('CREATE SCHEMA Generated');
END;
GO

IF EXISTS (
    SELECT * FROM sys.types 
    WHERE is_table_type = 1 
    AND name = N'{targetClassName}'
    AND schema_id = SCHEMA_ID(N'Generated')
)
BEGIN
    DECLARE @sql NVARCHAR(MAX) = N'DROP TYPE Generated.{targetClassName};';
    EXEC sp_executesql @sql;
END;
GO

CREATE TYPE Generated.{targetClassName} AS TABLE
(
    {string.Join(",\n       ", GetColumnNamesAndTypes(columnProperties).Select(x => $"{x.ColumnName} {x.SqlType}"))}
);
GO
";

        IEnumerable<(string ColumnName, string SqlType)> GetColumnNamesAndTypes(ICollection<ColumnPropertyInfo> columnProperties)
        {
            foreach (var columnProperty in columnProperties)
            {
                var typeSymbol = columnProperty.TypeSymbol;
                var sqlType = string.Empty;

                if (typeSymbol.ToString() == "System.Guid")
                {
                    sqlType = "uniqueidentifier";
                }

                sqlType = typeSymbol.SpecialType switch
                {
                    SpecialType.System_Boolean => "bit",
                    SpecialType.System_Byte => "tinyint",
                    SpecialType.System_SByte => "smallint",
                    SpecialType.System_Char => "nchar(1)",
                    SpecialType.System_Decimal => $"decimal({columnProperty.NumericPrecision}, {columnProperty.NumericScale})",
                    SpecialType.System_Double => "float",
                    SpecialType.System_Single => "real",
                    SpecialType.System_Int32 => "int",
                    SpecialType.System_Int64 => "bigint",
                    SpecialType.System_Int16 => "smallint",
                    SpecialType.System_String => "nvarchar(max)",
                    SpecialType.System_DateTime => "datetime2",
                    _ => "varbinary(max)"
                };

                var columnName = columnProperty.ColumnName;

                yield return (columnName, sqlType);
            }
        }
    }

    private void GenerateDataReader(SourceProductionContext context, string namespaceName, string targetClassName, string sourceClassName, ICollection<ColumnPropertyInfo> columnProperties)
    {
            var code = $$"""
// <auto-generated/>

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;

namespace {{namespaceName}}
{
    public class {{targetClassName}}DataReader : DbDataReader
    {
        private readonly IEnumerator<{{sourceClassName}}> _source;
        private {{sourceClassName}} _current;

        public {{targetClassName}}DataReader(IEnumerable<{{sourceClassName}}> source)
        {
            _source = source.GetEnumerator();
        }

        public override DataTable GetSchemaTable()
        {
            DataTable schemaTable = new DataTable()
            {
                Columns = {
                    {
                        "ColumnOrdinal",
                        typeof (int)
                    },
                    {
                        "ColumnName",
                        typeof (string)
                    },
                    {
                        "DataType",
                        typeof (Type)
                    },
                    {
                        "ColumnSize",
                        typeof (int)
                    },
                    {
                        "AllowDBNull",
                        typeof (bool)
                    },
                    {
                        "IsKey",
                        typeof (bool)
                    },
                    {
                        "NumericPrecision",
                        typeof (short)
                    },
                    {
                        "NumericScale",
                        typeof (short)
                    },
                }
            };

{{GetSchemaTableRows(columnProperties)}}

            return schemaTable;
        }
        
        public override bool GetBoolean(int ordinal)
        {
            return ordinal switch
            {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(Boolean))}}
                _ => throw new InvalidCastException(),
            };
        }

        public override byte GetByte(int ordinal)
        {
            return ordinal switch
            {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(Byte))}}
                _ => throw new InvalidCastException(),
            };
        }

        public override long GetBytes(int ordinal, long dataOffset, byte[]? buffer, int bufferOffset, int length)
        {
            throw new NotImplementedException();
        }

        public override char GetChar(int ordinal)
        {
            return ordinal switch
            {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(Char))}}
                _ => throw new InvalidCastException(),
            };
        }

        public override long GetChars(int ordinal, long dataOffset, char[]? buffer, int bufferOffset, int length)
        {
            var str = GetString(ordinal);
            var val2 = str.Length - (int)dataOffset;
            
            if (val2 <= 0)
            {
                return 0;
            }
            
            int count = Math.Min(length, val2);
            str.CopyTo((int) dataOffset, buffer, bufferOffset, count);
            return (long) count;
        }

        public override string GetDataTypeName(int ordinal)
        {
            return ordinal switch
            {
{{GetDataTypeNameSwitchExpression(columnProperties)}}
                _ => throw new ArgumentOutOfRangeException(nameof(ordinal))
            };
        }

        public override DateTime GetDateTime(int ordinal)
        {
            return ordinal switch
            {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(DateTime))}}
                _ => throw new InvalidCastException(),
            };
        }

        public override decimal GetDecimal(int ordinal)
        {
            return ordinal switch
            {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(Decimal))}}
                _ => throw new InvalidCastException(),
            };
        }

        public override double GetDouble(int ordinal)
        {
            return ordinal switch
            {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(Double))}}
                _ => throw new InvalidCastException(),
            };
        }

        public override Type GetFieldType(int ordinal)
        {
            return ordinal switch
            {
{{GetFieldTypeSwitchExpression(columnProperties)}}
                _ => throw new ArgumentOutOfRangeException(nameof(ordinal))
            };
        }

        public override float GetFloat(int ordinal)
        {
            return ordinal switch
            {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(Single))}}
                _ => throw new InvalidCastException(),
            };
        }

        public override Guid GetGuid(int ordinal)
        {
            return ordinal switch
            {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(Guid))}}
                _ => throw new InvalidCastException(),
            };
        }

        public override short GetInt16(int ordinal)
        {
            return ordinal switch
            {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(Int16))}}
                _ => throw new InvalidCastException(),
            };
        }

        public override int GetInt32(int ordinal)
        {
            return ordinal switch
            {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(Int32))}}
                _ => throw new InvalidCastException(),
            };
        }

        public override long GetInt64(int ordinal)
        {
            return ordinal switch
            {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(Int64))}}
                _ => throw new InvalidCastException(),
            };
        }

        public override string GetName(int ordinal)
        {
            return ordinal switch
            {
{{GetNameSwitchExpression(columnProperties)}}
                _ => throw new ArgumentOutOfRangeException(nameof(ordinal))
            };
        }

        public override int GetOrdinal(string name)
        {
            return name switch
            {
{{GetOrdinalSwitchExpression(columnProperties)}}
                _ => throw new ArgumentOutOfRangeException(nameof(name))
            };
        }

        public override string GetString(int ordinal)
        {
            return ordinal switch
            {
{{GetTypedValueSwitchExpressionByTypeName(columnProperties, nameof(String))}}
                _ => throw new InvalidCastException(),
            };
        }

        public override object GetValue(int ordinal)
        {
            return ordinal switch
            {
{{GetValueSwitchExpression(columnProperties)}}
                _ => throw new ArgumentOutOfRangeException(nameof(ordinal))
            };
        }

        public override int GetValues(object[] values)
        {
            throw new NotImplementedException();
        }

        public override bool IsDBNull(int ordinal)
        {
            return ordinal switch
            {
{{IsDbNullSwitchExpression(columnProperties)}}
                _ => throw new ArgumentOutOfRangeException(nameof(ordinal))
            };
        }

        public override int FieldCount => {{columnProperties.Count}};

        public override object this[int ordinal] => GetValue(ordinal);

        public override object this[string name] => GetValue(GetOrdinal(name));

        public override int RecordsAffected => 0;

        public override bool HasRows
        {
            get
            {
                var hasValue = _source.MoveNext();
                _source.Reset();
                return hasValue;
            }
        }

        public override bool IsClosed => false;

        public override bool NextResult()
        {
            throw new NotImplementedException();
        }

        public override bool Read()
        {
            if (_source.MoveNext())
            {
                _current = _source.Current;
                return true;
            }

            return false;
        }

        public override int Depth => 0;

        public override IEnumerator GetEnumerator()
        {
            return _source;
        }

        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            _source.Dispose();
        }
    }
}
""";

        context.AddSource($"{sourceClassName}DataReader.g.cs", SourceText.From(code, Encoding.UTF8));
    }

    private string GetSchemaTableRows(ICollection<ColumnPropertyInfo> columnProperties)
    {
        return string.Join("\n", columnProperties
            .Select(
                p =>
                {
                    var isNullable = p.TypeSymbol.IsReferenceType || p.TypeSymbol.NullableAnnotation == NullableAnnotation.Annotated;
                    return $"                schemaTable.Rows.Add({p.Ordinal}, \"{p.ColumnName}\", typeof({p.TypeSymbol.Name}), -1, {isNullable.ToString().ToLower()}, false, {p.NumericPrecision}, {p.NumericScale});";
                }));
    }

    private string IsDbNullSwitchExpression(ICollection<ColumnPropertyInfo> columnProperties)
    {
        return string.Join("\n", columnProperties
            .Select(p =>
                {
                    var isNullable = p.TypeSymbol.IsReferenceType || p.TypeSymbol.NullableAnnotation == NullableAnnotation.Annotated;
                    return $"                {p.Ordinal} => {(isNullable ? $"_current.{p.SourcePropertyName} is null" : "false")},";
                }
            ));
    }

    private string GetValueSwitchExpression(ICollection<ColumnPropertyInfo> columnProperties)
    {
        return string.Join("\n", columnProperties
            .Select(p => $"                {p.Ordinal} => _current.{p.SourcePropertyName},"));
    }

    private string GetOrdinalSwitchExpression(ICollection<ColumnPropertyInfo> columnProperties)
    {
        return string.Join("\n", columnProperties
            .Select(p => $"                \"{p.ColumnName}\"{(p.ColumnName != p.SourcePropertyName ? $" or \"{p.SourcePropertyName}\"": "")} => {p.Ordinal},"));
    }

    private string GetNameSwitchExpression(ICollection<ColumnPropertyInfo> columnProperties)
    {
        return string.Join("\n", columnProperties
            .Select(p => $"                {p.Ordinal} => \"{p.ColumnName}\","));
    }

    private string GetFieldTypeSwitchExpression(ICollection<ColumnPropertyInfo> columnProperties)
    {
        return string.Join("\n", columnProperties
            .Select(p => $"                {p.Ordinal} => typeof({p.TypeSymbol.Name}),"));
    }

    private string GetDataTypeNameSwitchExpression(ICollection<ColumnPropertyInfo> columnProperties)
    {
        return string.Join("\n", columnProperties
            .Select(p => $"                {p.Ordinal} => nameof({p.TypeSymbol.Name}),"));
    }

    private static string GetTypedValueSwitchExpressionByTypeName(ICollection<ColumnPropertyInfo> columnProperties, string typeName)
    {
        return string.Join("\n", columnProperties
            .Where(p => p.TypeSymbol.Name == typeName)
            .Select(p => $"                {p.Ordinal} => _current.{p.SourcePropertyName},"));
    }

    private static ICollection<ColumnPropertyInfo> GetColumnProperties(INamedTypeSymbol classSymbol)
    {
        if (classSymbol == null)
        {
            return Array.Empty<ColumnPropertyInfo>();
        }

        var properties = new List<ColumnPropertyInfo>();

        var props = classSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => !p.GetAttributes().Any(attr => attr.AttributeClass.Name == nameof(ColumnIgnoreAttribute)))
            .ToList();

        IEnumerable<ColumnPropertyInfo> targetProps;

        if (props.Any(p =>p.GetAttributes().Any(attr => attr.AttributeClass.Name == nameof(ColumnInfoAttribute))))
        {
            var propertyIndex = 0;
            targetProps = props
                .Select
                (
                    p =>
                    {
                        var targetAttr = p
                            .GetAttributes()
                            .FirstOrDefault(attr => attr.AttributeClass.Name == nameof(ColumnInfoAttribute));

                        if (targetAttr == null)
                        {
                            var propInfo = new ColumnPropertyInfo
                            (
                                propertyIndex,
                                p.Name,
                                p.Name,
                                p.Type,
                                (p.Type.Name == nameof(Decimal) ?(short)18 :(short)0),
                                (p.Type.Name == nameof(Decimal) ?(short)5 :(short)0)
                            );

                            propertyIndex++;
                            return propInfo;
                        }

                        var columnNameProp = targetAttr.NamedArguments
                            .FirstOrDefault(x => x.Key == nameof(ColumnInfoAttribute.ColumnName));

                        var columnName = columnNameProp.Value.Value as string ?? p.Name;

                        var ordinal = targetAttr.NamedArguments
                            .FirstOrDefault(x => x.Key == nameof(ColumnInfoAttribute.Ordinal))
                            .Value.Value as int? ?? propertyIndex;

                        var numericPrecision = targetAttr.NamedArguments
                               .FirstOrDefault(x => x.Key == nameof(ColumnInfoAttribute.NumericPrecision))
                               .Value.Value as short?
                           ?? (p.Type.Name == nameof(Decimal) ? (short)18 : (short)0);

                        var numericScale = targetAttr.NamedArguments
                               .FirstOrDefault(x => x.Key == nameof(ColumnInfoAttribute.NumericScale))
                               .Value.Value as short?
                           ?? (p.Type.Name == nameof(Decimal) ? (short)5 : (short)0);

                        propertyIndex++;

                        return new ColumnPropertyInfo(ordinal, columnName, p.Name, p.Type, numericPrecision, numericScale);
                    }
                )
                .OrderBy(p => p.Ordinal);
        }
        else
        {
            var propertyIndex = 0;
            targetProps = props
                .Select
                (
                    p =>
                    {
                        var propInfo = new ColumnPropertyInfo
                        (
                            propertyIndex,
                            p.Name,
                            p.Name,
                            p.Type,
                            (p.Type.Name == nameof(Decimal) ?(short)18 :(short)0),
                            (p.Type.Name == nameof(Decimal) ?(short)5 :(short)0)
                        );

                        propertyIndex++;
                        return propInfo;
                    }
                )
                .OrderBy(p => p.Ordinal);
        }


        properties.AddRange(targetProps);

        return properties;
    }
}
